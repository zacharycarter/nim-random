# Code in this module is based on:
# http://xorshift.di.unimi.it/murmurhash3.c
#
# It was ported to Nim in 2015 by Oleh Prypin <blaxpirit@gmail.com>
#
# The following are the verbatim comments from the original code:

discard """

Written in 2014 by Sebastiano Vigna (vigna@acm.org)

To the extent possible under law, the author has dedicated all copyright
and related and neighboring rights to this software to the public domain
worldwide. This software is distributed without any warranty.

See <http://creativecommons.org/publicdomain/zero/1.0/>.


This is actually not a generator. It is the finalization phase of
MurmurHash3 (https://code.google.com/p/smhasher/wiki/MurmurHash3),
iterated. As the author states,

   The constants for the finalizers were generated by a simple
   simulated-annealing algorithm, and both [32/64 bits] avalanche all
   bits of 'x' to within 0.25% bias.

The multipliers are invertible in Z/2^64Z, and the xor/shifts are
invertible in (Z/2Z)^64, so you'll never get zero starting from a
nonzero value. Nonetheless, we have no clue of the period. In
principle, hitting a bad seed you might get into a very short repeating
sequence.

The interesting thing is that it passes very well the strongest
statistical tests. It can be useful to scramble user-provided 64-bit
seeds.

"""


# The state must be seeded with a nonzero value.
proc next*(x: uint64): uint64 =
  var x = x xor (x shr 33)
  x *= 0xff51afd7ed558ccd'u64
  x = x xor (x shr 33)
  x *= 0xc4ceb9fe1a85ec53'u64
  return x xor (x shr 33)
